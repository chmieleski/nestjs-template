# Cursor Rules v2 - NestJS TypeScript Project

## Project Context
You are working on a NestJS v11 TypeScript backend application with strict typing, clean architecture, and comprehensive testing.

## Core Principles

### TypeScript General Guidelines

#### Basic Principles
- Use English for all code and documentation
- Always declare explicit types for variables, function parameters, and return values
- Never use `any` type - create proper types instead
- Use JSDoc comments to document all public classes and methods
- No blank lines within function bodies
- One export per file (default export preferred for classes/modules)

#### Nomenclature
- **Classes**: PascalCase (e.g., `UserService`, `OrderController`)
- **Variables, functions, methods**: camelCase (e.g., `getUserById`, `isValid`)
- **Files and directories**: kebab-case (e.g., `user-service.ts`, `order-controller.ts`)
- **Environment variables**: UPPERCASE (e.g., `DATABASE_URL`, `JWT_SECRET`)
- **Constants**: UPPERCASE with meaningful names, avoid magic numbers
- **Function names**: Start with a verb (e.g., `createUser`, `validateInput`, `transformData`)
- **Boolean variables**: Use verbs like `is`, `has`, `can`, `should` (e.g., `isLoading`, `hasError`, `canDelete`, `shouldValidate`)
- **Complete words**: Use full words instead of abbreviations, except:
  - Standard abbreviations: API, URL, HTTP, JSON, etc.
  - Well-known abbreviations: `i`, `j` for loops; `err` for errors; `ctx` for contexts; `req`, `res`, `next` for middleware parameters

#### Functions
- Keep functions short and focused - maximum 20 instructions per function
- Single responsibility principle - one purpose per function
- Function naming convention:
  - Boolean returns: `isX`, `hasX`, `canX`, `shouldX`
  - Void/actions: `executeX`, `saveX`, `deleteX`, `createX`
- Avoid nested blocks by:
  - Early returns and guard clauses
  - Extracting complex logic to utility functions
- Prefer higher-order functions (map, filter, reduce) over manual loops
  - Use arrow functions for simple operations (< 3 instructions)
  - Use named functions for complex operations
- Use default parameter values instead of null/undefined checks
- Reduce function parameters using RO-RO pattern (Receive Object, Return Object):
  - Pass multiple parameters as a single object
  - Return results as objects with named properties
  - Declare proper types for input and output objects

#### Data Handling
- Avoid primitive obsession - encapsulate data in composite types
- Move data validation to DTOs/entities with class-validator, not in business logic
- Prefer immutability:
  - Use `readonly` for properties that don't change
  - Use `as const` for literal values that don't change
  - Use readonly arrays when appropriate

#### Classes
- Follow SOLID principles strictly
- Prefer composition over inheritance
- Declare interfaces to define contracts
- Keep classes small and focused:
  - Maximum 200 instructions per class
  - Maximum 10 public methods per class
  - Maximum 10 properties per class

#### Error Handling
- Use exceptions for unexpected errors
- Catch exceptions only to:
  - Fix expected problems
  - Add contextual information
  - Otherwise, let global exception filters handle them
- Use NestJS exception filters for consistent error responses

#### Testing
- Follow Arrange-Act-Assert (AAA) pattern for unit tests
- Use clear variable naming in tests:
  - `inputX`, `mockX`, `actualX`, `expectedX`
- Write unit tests for all public functions
- Use test doubles (mocks, stubs, spies) for dependencies
  - Exception: third-party dependencies that are inexpensive to execute
- Write acceptance tests for each module using Given-When-Then convention

## NestJS Specific Guidelines

### Architecture Principles
- Use modular architecture - each feature domain gets its own module
- Encapsulate API endpoints in feature modules:
  - One module per main domain/route
  - One controller per route (with additional controllers for sub-routes)
  - Models folder containing:
    - DTOs validated with class-validator for inputs
    - Simple types/interfaces for outputs
  - Services folder containing:
    - Business logic and data persistence
    - Entities (if using MikroORM/TypeORM)
    - One service per entity/domain aggregate
- Core module for NestJS artifacts:
  - Global exception filters for consistent error handling
  - Global guards for authentication/authorization
  - Global interceptors for cross-cutting concerns (logging, transformation, etc.)
  - Global pipes for validation and transformation
- Shared module for reusable services and utilities:
  - Common business logic shared across modules
  - Utility functions and helpers
  - Shared types and interfaces

### Module Structure
```
src/
├── core/                    # Core NestJS artifacts
│   ├── filters/            # Exception filters
│   ├── guards/             # Authentication/authorization guards
│   ├── interceptors/       # Request/response interceptors
│   ├── pipes/              # Validation/transformation pipes
│   └── decorators/         # Custom decorators
├── shared/                  # Shared utilities and services
│   ├── services/           # Shared business services
│   ├── utils/              # Utility functions
│   └── types/              # Shared types and interfaces
└── [feature]/              # Feature modules
    ├── [feature].module.ts
    ├── [feature].controller.ts
    ├── [feature].service.ts
    ├── dto/                # Data Transfer Objects
    │   ├── create-[feature].dto.ts
    │   ├── update-[feature].dto.ts
    │   └── [feature]-response.dto.ts
    └── entities/           # Database entities (if applicable)
```

### Controllers
- Use decorators from `@nestjs/common` for route definitions
- Keep controllers thin - delegate business logic to services
- Use DTOs for all request/response bodies
- Use proper HTTP status codes and decorators (`@Get()`, `@Post()`, `@Put()`, `@Delete()`, `@Patch()`)
- Use `@Param()`, `@Query()`, `@Body()` decorators with proper typing
- Document endpoints with Swagger decorators (`@ApiTags()`, `@ApiOperation()`, `@ApiResponse()`)
- Add a smoke test endpoint (e.g., `GET /admin/test`) to each controller

### Services
- Use `@Injectable()` decorator
- Inject dependencies via constructor injection
- Keep business logic in services, not controllers
- Use async/await for asynchronous operations
- Return proper types, not raw database entities
- Handle errors and throw appropriate NestJS exceptions (`NotFoundException`, `BadRequestException`, etc.)

### DTOs (Data Transfer Objects)
- Create separate DTOs for create, update, and response operations
- Use class-validator decorators for validation:
  - `@IsString()`, `@IsNumber()`, `@IsEmail()`, `@IsOptional()`, `@IsNotEmpty()`, etc.
  - `@Min()`, `@Max()`, `@Length()` for constraints
- Use class-transformer decorators when needed:
  - `@Exclude()`, `@Expose()`, `@Transform()`
- Use `ValidationPipe` globally or per endpoint with `transform: true`
- Define simple types/interfaces for response DTOs (not classes with validation)

### Dependency Injection
- Use constructor injection for all dependencies
- Prefer interfaces for dependency contracts (use `@Inject()` with token)
- Use `@InjectRepository()` for database repositories
- Use `@Inject()` with custom tokens for complex dependencies
- Avoid property injection - use constructor injection only

### Exception Handling
- Use NestJS built-in exceptions:
  - `BadRequestException` for validation errors
  - `UnauthorizedException` for authentication failures
  - `ForbiddenException` for authorization failures
  - `NotFoundException` for missing resources
  - `ConflictException` for duplicate resources
  - `InternalServerErrorException` for unexpected errors
- Create custom exception filters for domain-specific errors
- Use global exception filters for consistent error response format

### Validation
- Enable global `ValidationPipe` in `main.ts`:
  ```typescript
  app.useGlobalPipes(new ValidationPipe({
    whitelist: true,
    forbidNonWhitelisted: true,
    transform: true,
    transformOptions: { enableImplicitConversion: true }
  }));
  ```
- Validate all inputs using DTOs with class-validator
- Use custom validators for complex validation logic

### Guards
- Use guards for authentication and authorization
- Implement `CanActivate` interface
- Use `@UseGuards()` decorator at controller or method level
- Create custom guards for role-based access control (RBAC)

### Interceptors
- Use interceptors for:
  - Logging requests/responses
  - Transforming responses
  - Caching
  - Timeout handling
- Implement `NestInterceptor` interface
- Use `@UseInterceptors()` decorator

### Pipes
- Use pipes for:
  - Validation (ValidationPipe)
  - Transformation (ParseIntPipe, ParseBoolPipe, etc.)
  - Custom parsing logic
- Create custom pipes for domain-specific transformations

### Configuration
- Use `@nestjs/config` for environment configuration
- Create configuration modules for different environments
- Use `.env` files with proper validation
- Access config via `ConfigService` injection

### Testing
- Use Jest framework (standard for NestJS)
- Use `@nestjs/testing` TestingModule for integration tests
- Write unit tests for all controllers and services:
  - Test happy paths and error cases
  - Mock dependencies using Jest mocks
  - Use `describe`, `it`, `expect` structure
- Write E2E tests for each API module:
  - Use `supertest` for HTTP testing
  - Test full request/response cycle
  - Test authentication/authorization flows
- Test naming: `*.spec.ts` for unit tests, `*.e2e-spec.ts` for E2E tests
- Use `Test.createTestingModule()` for setting up test modules
- Mock external dependencies (databases, APIs) in tests

### Database (when using ORM)
- Use repository pattern
- Keep entities simple - business logic in services
- Use transactions for multi-step operations
- Use migrations for schema changes
- Validate data at DTO level, not entity level

### Documentation
- Use Swagger/OpenAPI (`@nestjs/swagger`) for API documentation
- Add `@ApiTags()` to controllers
- Add `@ApiOperation()` to endpoints
- Add `@ApiResponse()` for response documentation
- Use `@ApiProperty()` on DTOs for schema documentation

### Performance
- Use async/await, not raw Promises
- Implement proper pagination for list endpoints
- Use caching where appropriate (`@nestjs/cache-manager`)
- Avoid N+1 queries in database operations
- Use connection pooling for database connections

### Security
- Validate and sanitize all inputs
- Use parameterized queries (via ORM)
- Implement proper authentication (JWT, OAuth, etc.)
- Use guards for authorization checks
- Sanitize error messages to avoid information leakage
- Use HTTPS in production
- Implement rate limiting where appropriate

## Code Generation Preferences
- When creating new modules, use NestJS CLI: `nest g module [name]`
- When creating controllers/services, follow NestJS CLI conventions
- Use path aliases from tsconfig.json for imports (e.g., `@/core`, `@/shared`)
- Prefer dependency injection over static methods
- Use decorators for metadata and cross-cutting concerns

## Package Manager
- This project uses **yarn** as the package manager
- Always use `yarn` commands instead of `npm`:
  - `yarn add <package>` for installing dependencies
  - `yarn add -D <package>` for installing dev dependencies
  - `yarn install` for installing all dependencies
  - `yarn remove <package>` for removing packages

## File Organization
- Group related files in feature folders
- Keep test files next to source files (`.spec.ts` alongside `.ts`)
- Separate E2E tests in `test/` directory
- Use index files for clean exports from modules

